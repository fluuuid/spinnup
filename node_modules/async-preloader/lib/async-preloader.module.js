import { __awaiter, __generator, __assign } from 'tslib';
import FontFaceObserver from 'fontfaceobserver';
import { get } from 'lodash';

/**
 * Keys used for the [[AsyncPreloader.loaders]]
 */
var LoaderKey;
(function (LoaderKey) {
    LoaderKey["Json"] = "Json";
    LoaderKey["ArrayBuffer"] = "ArrayBuffer";
    LoaderKey["Blob"] = "Blob";
    LoaderKey["FormData"] = "FormData";
    LoaderKey["Text"] = "Text";
    LoaderKey["Image"] = "Image";
    LoaderKey["Video"] = "Video";
    LoaderKey["Audio"] = "Audio";
    LoaderKey["Xml"] = "Xml";
    LoaderKey["Font"] = "Font";
})(LoaderKey || (LoaderKey = {}));

/**
 * AsyncPreloader: assets preloader using ES2017 async/await and fetch.
 *
 * It exports an instance of itself as default so you can:
 *
 * ```js
 * import Preloader from "async-preloader";
 *
 * await Preloader.loadItems([]);
 * ```
 *
 * to use directly as a singleton or
 *
 * ```js
 * import { AsyncPreloader as Preloader } from "async-preloader";
 *
 * const preloader = new Preloader();
 * await preloader.loadItems([]);
 * ```
 * if you need more than one instance.
 */
var AsyncPreloader = /** @class */ (function () {
    function AsyncPreloader() {
        var _this = this;
        // Properties
        /**
         * Object that contains the loaded items
         */
        this.items = new Map();
        /**
         * Default body method to be called on the Response from fetch if no body option is specified on the LoadItem
         */
        this.defaultBodyMethod = "blob";
        /**
         * Default loader to use if no loader key is specified in the [[LoadItem]] or if the extension doesn't match any of the [[AsyncPreloader.loaders]] extensions
         */
        this.defaultLoader = LoaderKey.Text;
        // API
        /**
         * Load the specified manifest (array of items)
         *
         * @param {LoadItem[]} items Items to load
         * @returns {Promise<LoadedValue[]>} Resolve when all items are loaded, reject for any error
         */
        this.loadItems = function (items) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(items.map(this.loadItem))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        }); };
        /**
         * Load a single item
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<LoadedValue>} Resolve when item is loaded, reject for any error
         */
        this.loadItem = function (item) { return __awaiter(_this, void 0, void 0, function () {
            var extension, loaderKey, mimeType, loadedItem;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        extension = AsyncPreloader.getFileExtension(item.src);
                        loaderKey = item.loader || AsyncPreloader.getLoaderKey(extension);
                        if (loaderKey === "Xml" && !item.mimeType) {
                            mimeType = AsyncPreloader.loaders.get(LoaderKey.Xml).mimeType[extension] ||
                                AsyncPreloader.loaders.get(LoaderKey.Xml).mimeType["svg"];
                            item = __assign({}, item, { mimeType: mimeType });
                        }
                        return [4 /*yield*/, this["load" + loaderKey](item)];
                    case 1:
                        loadedItem = _a.sent();
                        this.items.set(item.id || item.src, loadedItem);
                        return [2 /*return*/, loadedItem];
                }
            });
        }); };
        // Special loaders
        /**
         * Load a manifest of items
         *
         * @param {string} src Manifest src url
         * @param {string} [key="items"] Manifest key in the JSON object containing the array of LoadItem. Used by [lodash.get](https://lodash.com/docs/4.17.5#get).
         * @returns {Promise<LoadedValue[]>}
         */
        this.loadManifest = function (src, key) {
            if (key === void 0) { key = "items"; }
            return __awaiter(_this, void 0, void 0, function () {
                var loadedManifest, items;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.loadJson({
                                src: src
                            })];
                        case 1:
                            loadedManifest = _a.sent();
                            items = get(loadedManifest, key);
                            return [4 /*yield*/, this.loadItems(items)];
                        case 2: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        // Text loaders
        /**
         * Load an item and parse the Response as text
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response
         */
        this.loadText = function (item) { return __awaiter(_this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, AsyncPreloader.fetchItem(item)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.text()];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        }); };
        /**
         * Load an item and parse the Response as json
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response
         */
        this.loadJson = function (item) { return __awaiter(_this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, AsyncPreloader.fetchItem(item)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.json()];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        }); };
        /**
         * Load an item and parse the Response as arrayBuffer
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response
         */
        this.loadArrayBuffer = function (item) { return __awaiter(_this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, AsyncPreloader.fetchItem(item)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.arrayBuffer()];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        }); };
        /**
         * Load an item and parse the Response as blob
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response
         */
        this.loadBlob = function (item) { return __awaiter(_this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, AsyncPreloader.fetchItem(item)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.blob()];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        }); };
        /**
         * Load an item and parse the Response as formData
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response
         */
        this.loadFormData = function (item) { return __awaiter(_this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, AsyncPreloader.fetchItem(item)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.formData()];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        }); };
        // Custom loaders
        /**
         * Load an item in one of the following cases:
         * - item's "loader" option set as "Image"
         * - item's "src" option extensions matching the loaders Map
         * - direct call of the method
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response according to the "body" option. Defaults to an HTMLImageElement with a blob as src.
         */
        this.loadImage = function (item) { return __awaiter(_this, void 0, void 0, function () {
            var response, data, image;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, AsyncPreloader.fetchItem(item)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response[item.body || this.defaultBodyMethod]()];
                    case 2:
                        data = _a.sent();
                        if (item.body && item.body !== this.defaultBodyMethod) {
                            return [2 /*return*/, data];
                        }
                        image = new Image();
                        image.src = URL.createObjectURL(data);
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                image.addEventListener("load", function () { return resolve(image); }, false);
                                image.addEventListener("error", reject, false);
                            })];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        }); };
        /**
         * Load an item in one of the following cases:
         * - item's "loader" option set as "Video"
         * - item's "src" option extensions matching the loaders Map
         * - direct call of the method
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response according to the "body" option. Defaults to an HTMLVideoElement with a blob as src.
         */
        this.loadVideo = function (item) { return __awaiter(_this, void 0, void 0, function () {
            var response, data, video;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, AsyncPreloader.fetchItem(item)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response[item.body || this.defaultBodyMethod]()];
                    case 2:
                        data = _a.sent();
                        if (item.body && item.body !== this.defaultBodyMethod) {
                            return [2 /*return*/, data];
                        }
                        video = document.createElement("video");
                        video.src = URL.createObjectURL(data);
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                video.addEventListener("canplaythrough", function () { return resolve(video); }, false);
                                video.addEventListener("error", reject, false);
                            })];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        }); };
        /**
         * Load an item in one of the following cases:
         * - item's "loader" option set as "Audio"
         * - item's "src" option extensions matching the loaders Map
         * - direct call of the method
         *
         * @param {LoadItem} item Item to load
         * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response according to the "body" option. Defaults to an HTMLAudioElement with a blob as src.
         */
        this.loadAudio = function (item) { return __awaiter(_this, void 0, void 0, function () {
            var response, data, audio;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, AsyncPreloader.fetchItem(item)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response[item.body || this.defaultBodyMethod]()];
                    case 2:
                        data = _a.sent();
                        if (item.body && item.body !== this.defaultBodyMethod) {
                            return [2 /*return*/, data];
                        }
                        audio = document.createElement("audio");
                        audio.autoplay = false;
                        audio.preload = "auto";
                        audio.src = URL.createObjectURL(data);
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                audio.addEventListener("canplaythrough", function () { return resolve(audio); }, false);
                                audio.addEventListener("error", reject, false);
                            })];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        }); };
        /**
         * Load an item in one of the following cases:
         * - item's "loader" option set as "Xml"
         * - item's "src" option extensions matching the loaders Map
         * - direct call of the method
         *
         * @param {LoadItem} item Item to load (need a mimeType specified or default to "application/xml")
         * @returns {Promise<LoadedXMLValue>} Result of Response parsed as a document.
         */
        this.loadXml = function (item) { return __awaiter(_this, void 0, void 0, function () {
            var response, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, AsyncPreloader.fetchItem(item)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.text()];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, AsyncPreloader.domParser.parseFromString(data, item.mimeType)];
                }
            });
        }); };
        this.loadFont = function (item) { return __awaiter(_this, void 0, void 0, function () {
            var fontName, font;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fontName = item.id || AsyncPreloader.getFileName(item.src);
                        font = new FontFaceObserver(fontName, item.options || {});
                        return [4 /*yield*/, font.load()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, fontName];
                }
            });
        }); };
    }
    // Utils
    /**
     * Fetch wrapper for LoadItem
     *
     * @param {LoadItem} item Item to fetch
     * @returns {Promise<Response>} Fetch response
     */
    AsyncPreloader.fetchItem = function (item) {
        return fetch(item.src, item.options || {});
    };
    /**
     * Get file extension from path
     *
     * @param {(RequestInfo | USVString)} path
     * @returns {string}
     */
    AsyncPreloader.getFileExtension = function (path) {
        return (path.match(/[^\\\/]\.([^.\\\/]+)$/) || [null]).pop();
    };
    /**
     * Get file name from path
     *
     * @param {any} path
     * @returns {string}
     */
    AsyncPreloader.getFileName = function (path) {
        return path
            .replace(/^.*[\\\/]/, "")
            .split(".")
            .shift();
    };
    /**
     * Retrieve loader key from extension (when the loader option isn't specified in the LoadItem)
     *
     * @param {string} extension
     * @returns {LoaderKey}
     */
    AsyncPreloader.getLoaderKey = function (extension) {
        var loader = Array.from(AsyncPreloader.loaders).find(function (loader) {
            return loader[1].extensions.includes(extension);
        });
        return loader ? loader[0] : LoaderKey.Text;
    };
    /**
     * Loader types and the extensions they handle
     *
     * Allows the omission of the loader key in a [[LoadItem.loader]] for some generic extensions
     */
    AsyncPreloader.loaders = new Map()
        .set(LoaderKey.Text, { extensions: ["txt"] })
        .set(LoaderKey.Json, { extensions: ["json"] })
        .set(LoaderKey.Image, { extensions: ["jpeg", "jpg", "gif", "png", "webp"] })
        .set(LoaderKey.Video, { extensions: ["webm", "ogg", "mp4"] })
        .set(LoaderKey.Audio, { extensions: ["webm", "ogg", "mp3", "wav", "flac"] })
        .set(LoaderKey.Xml, {
        extensions: ["xml", "svg", "html"],
        mimeType: {
            xml: "application/xml",
            svg: "image/svg+xml",
            html: "text/html"
        }
    })
        .set(LoaderKey.Font, {
        extensions: ["woff2", "woff", "ttf", "otf", "eot"]
    });
    /**
     * DOMParser instance for the XML loader
     */
    AsyncPreloader.domParser = new DOMParser();
    return AsyncPreloader;
}());
var AsyncPreloaderInstance = new AsyncPreloader();

export default AsyncPreloaderInstance;
export { AsyncPreloader };
