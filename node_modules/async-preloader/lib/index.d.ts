import { BodyMethod, LoadItem, LoadedValue, LoadedXMLValue, LoaderKey } from "./types";
/**
 * AsyncPreloader: assets preloader using ES2017 async/await and fetch.
 *
 * It exports an instance of itself as default so you can:
 *
 * ```js
 * import Preloader from "async-preloader";
 *
 * await Preloader.loadItems([]);
 * ```
 *
 * to use directly as a singleton or
 *
 * ```js
 * import { AsyncPreloader as Preloader } from "async-preloader";
 *
 * const preloader = new Preloader();
 * await preloader.loadItems([]);
 * ```
 * if you need more than one instance.
 */
declare class AsyncPreloader {
    /**
     * Object that contains the loaded items
     */
    items: Map<string, LoadedValue>;
    /**
     * Default body method to be called on the Response from fetch if no body option is specified on the LoadItem
     */
    defaultBodyMethod: BodyMethod;
    /**
     * Default loader to use if no loader key is specified in the [[LoadItem]] or if the extension doesn't match any of the [[AsyncPreloader.loaders]] extensions
     */
    defaultLoader: LoaderKey;
    /**
     * Loader types and the extensions they handle
     *
     * Allows the omission of the loader key in a [[LoadItem.loader]] for some generic extensions
     */
    private static loaders;
    /**
     * DOMParser instance for the XML loader
     */
    private static domParser;
    /**
     * Load the specified manifest (array of items)
     *
     * @param {LoadItem[]} items Items to load
     * @returns {Promise<LoadedValue[]>} Resolve when all items are loaded, reject for any error
     */
    loadItems: (items: LoadItem[]) => Promise<LoadedValue[]>;
    /**
     * Load a single item
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<LoadedValue>} Resolve when item is loaded, reject for any error
     */
    loadItem: (item: LoadItem) => Promise<LoadedValue>;
    /**
     * Load a manifest of items
     *
     * @param {string} src Manifest src url
     * @param {string} [key="items"] Manifest key in the JSON object containing the array of LoadItem. Used by [lodash.get](https://lodash.com/docs/4.17.5#get).
     * @returns {Promise<LoadedValue[]>}
     */
    loadManifest: (src: string, key?: string) => Promise<LoadedValue[]>;
    /**
     * Load an item and parse the Response as text
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response
     */
    loadText: (item: LoadItem) => Promise<LoadedValue>;
    /**
     * Load an item and parse the Response as json
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response
     */
    loadJson: (item: LoadItem) => Promise<LoadedValue>;
    /**
     * Load an item and parse the Response as arrayBuffer
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response
     */
    loadArrayBuffer: (item: LoadItem) => Promise<LoadedValue>;
    /**
     * Load an item and parse the Response as blob
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response
     */
    loadBlob: (item: LoadItem) => Promise<LoadedValue>;
    /**
     * Load an item and parse the Response as formData
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response
     */
    loadFormData: (item: LoadItem) => Promise<LoadedValue>;
    /**
     * Load an item in one of the following cases:
     * - item's "loader" option set as "Image"
     * - item's "src" option extensions matching the loaders Map
     * - direct call of the method
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response according to the "body" option. Defaults to an HTMLImageElement with a blob as src.
     */
    loadImage: (item: LoadItem) => Promise<LoadedValue>;
    /**
     * Load an item in one of the following cases:
     * - item's "loader" option set as "Video"
     * - item's "src" option extensions matching the loaders Map
     * - direct call of the method
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response according to the "body" option. Defaults to an HTMLVideoElement with a blob as src.
     */
    loadVideo: (item: LoadItem) => Promise<LoadedValue>;
    /**
     * Load an item in one of the following cases:
     * - item's "loader" option set as "Audio"
     * - item's "src" option extensions matching the loaders Map
     * - direct call of the method
     *
     * @param {LoadItem} item Item to load
     * @returns {Promise<LoadedValue>} Fulfilled value of parsed Response according to the "body" option. Defaults to an HTMLAudioElement with a blob as src.
     */
    loadAudio: (item: LoadItem) => Promise<LoadedValue>;
    /**
     * Load an item in one of the following cases:
     * - item's "loader" option set as "Xml"
     * - item's "src" option extensions matching the loaders Map
     * - direct call of the method
     *
     * @param {LoadItem} item Item to load (need a mimeType specified or default to "application/xml")
     * @returns {Promise<LoadedXMLValue>} Result of Response parsed as a document.
     */
    loadXml: (item: LoadItem) => Promise<LoadedXMLValue>;
    loadFont: (item: LoadItem) => Promise<string>;
    /**
     * Fetch wrapper for LoadItem
     *
     * @param {LoadItem} item Item to fetch
     * @returns {Promise<Response>} Fetch response
     */
    private static fetchItem(item);
    /**
     * Get file extension from path
     *
     * @param {(RequestInfo | USVString)} path
     * @returns {string}
     */
    private static getFileExtension(path);
    /**
     * Get file name from path
     *
     * @param {any} path
     * @returns {string}
     */
    private static getFileName(path);
    /**
     * Retrieve loader key from extension (when the loader option isn't specified in the LoadItem)
     *
     * @param {string} extension
     * @returns {LoaderKey}
     */
    private static getLoaderKey(extension);
}
export { AsyncPreloader };
declare const AsyncPreloaderInstance: AsyncPreloader;
export default AsyncPreloaderInstance;
